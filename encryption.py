from random import randint



class Encryption:
    def __init__(self, language: str):
        """Allows you to use Encryption with basic languages.

        Automatically supporting:
        - English 'eng',
        - Russian 'rus'.

        Throws ValueError if language is not supporting. 
        """

        if language not in ('eng', 'rus'):
            raise ValueError('{} is not a supporting language'.format(language))
        self._language = language

    def encrypt_caesar(self, text: str, shift: int) -> str:
        """Encrypt text using the Caesar cipher and returns the result.

        shift may be negative.
        """

        ciphertext = str()
        for char in text:
            ciphertext += self._get_shifted_char(char, shift)
        return ciphertext

    def decrypt_caesar(self, ciphertext: str, shift: int) -> str:
        """Decrypt ciphertext using the Caesar cipher and returns the result.

        You need to know shift to decrypt ciphertext.
        shift may be negative.
        """

        return self.encrypt_caesar(ciphertext, -shift)

    def encrypt_vigenere(self, text: str, key: str) -> str:
        """Encrypt text using the Vigenere cipher and returns the result.

        key may be any text in the same language, e.x. 'Aba+1 isn't Caba!'
        """

        shifts: list[int] = list()
        for char in key:
            shifts.append(self._to_number(char))
        return self._get_shifted_text(text, shifts)

    def decrypt_vigenere(self, ciphertext: str, key: str) -> str:
        """Encrypt text using the Vigenere cipher and returns the result.

        You need to know shift to decrypt ciphertext.
        key may be any text in the same language, e.x. 'Aba+1 isn't Caba!'
        """

        shifts: list[int] = list()
        for char in key:
            shifts.append(-self._to_number(char))
        return self._get_shifted_text(ciphertext, shifts)

    def encrypt_verman(self, text: str) -> tuple[str, str]:
        """Generate key and encrypt text using the Verman cipher with this key.

        Returns pair <ciphertext, key>.
        len(key) = len(ciphertext) = len(text).

        key uses only lower and upper letters.
        """

        shifts = self._get_random_shifts(text)
        key = self._to_key(text, shifts)
        ciphertext = self._get_shifted_text(text, shifts)
        return ciphertext, key

    def decrypt_verman(self, ciphertext: str, key: str) -> str:
        """Decrypt ciphertext using Verman cipher with key and return results

        key may be any text in the same language, e.x. 'Aba+1 isn't Caba!'
        len(key) = len(ciphertext), else throws a ValueError exception.
        """

        if len(ciphertext) != len(key):
            raise ValueError('len(key) must be equal len(ciphertext)!')
        return self.decrypt_vigenere(ciphertext, key)

    def _to_key(self, text: str, shifts: list[int]) -> str:
        """Returns the key-text generated by shifts using _to_char(shifts[i]).

        len(key) = len(shifts).
        text[i] is upper -> key[i] is upper,
        text[i] is lower or not letter -> key[i] is lower.

        shifts[i] must be >= 0. If shifts[i] < 0 throws an IndexError exception.
        """

        key = str()
        for i in range(0, len(shifts)):
            char = self._to_char(shifts[i])
            key += (char.upper() if text[i].isupper() else char)
        return key

    def _get_random_shifts(self, text: str) -> list[int]:
        """Returns list of random int nums in [0, len(alphabet)) using randint().

        len(shifts) = len(text).
        """

        shifts: list[int] = list()
        for i in range(0, len(text)):
            shift = randint(0, len(self._alphabets[self._language]) - 1)
            shifts.append(shift)
        return shifts

    def _get_shifted_text(self, text: str, shifts: list[int]) -> str:
        """Returns shifted_text each char of which is shifted text[i].

        text[i] cyclically shifted by shifts[i % len(shifts)] positions in order
        self._get_shifted_char(text[i], shifts[i % len(shifts)]).

        E.x.: text = 'Ax Y1', shifts = (-1, 2, 3) -> shifted_text = 'Zz  X1'.
        """

        shifted_text = str()
        for i in range(0, len(text)):
            shift = shifts[i % len(shifts)]
            shifted_text += self._get_shifted_char(text[i], shift)
        return shifted_text

    def _get_shifted_char(self, char: str, shift: int) -> str:
        """Returns char cyclically shifted by shift positions in the alphabet.

        Upper -> shifted upper,
        Lower -> shifted lower,
        If char is not in the alphabet it does not change.

        shift may be negative.
        """

        if char.lower() not in self._alphabets[self._language]:
            return char

        num = self._to_number(char)
        num = (num + shift) % len(self._alphabets[self._language])
        shifted_char = self._to_char(num)

        if char.isupper():
            return shifted_char.upper()
        return shifted_char

    def _to_number(self, char: str) -> int:
        """Returns the number of char in the alphabet at 0-indexing.

        Works with lower and upper chars.
        If char is not in the alphabet throws an ValueError exception.
        """

        return self._alphabets[self._language].index(char.lower())

    def _to_char(self, num: int) -> str:
        """Returns the num-th lower char of the alphabet at 0-indexing."""

        return self._alphabets[self._language][num]

    _alphabets: dict[str, str] = {'rus': 'абвгдеёжзийклмнопрстуфхцчшщъыьэюя',
                                  'eng': 'abcdefghijklmnopqrstuvwxyz'}

    _language: str
